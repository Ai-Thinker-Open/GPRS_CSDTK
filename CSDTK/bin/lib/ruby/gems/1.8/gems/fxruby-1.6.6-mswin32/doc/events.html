<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Chapter&nbsp;8.&nbsp;FXRuby's Message-Target System</title><link rel="stylesheet" href="style.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.68.1"><link rel="start" href="book.html" title="Developing Graphical User Interfaces with FXRuby"><link rel="up" href="pt01.html" title="Part&nbsp;I.&nbsp;The Basics"><link rel="prev" href="examples.html" title="Chapter&nbsp;7.&nbsp;Examples"><link rel="next" href="todo.html" title="Chapter&nbsp;9.&nbsp;To-do list"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter&nbsp;8.&nbsp;FXRuby's Message-Target System</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="examples.html">Prev</a>&nbsp;</td><th width="60%" align="center">Part&nbsp;I.&nbsp;The Basics</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="todo.html">Next</a></td></tr></table><hr></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="events"></a>Chapter&nbsp;8.&nbsp;FXRuby's Message-Target System</h2></div></div></div><div class="simplesect" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e2075"></a>Background</h2></div></div></div><p>One of the biggest flaws with earlier releases of FXRuby was its strict reproduction of FOX's process for mapping GUI events (messages) to instance methods (handlers). That process involved four distinct steps:</p><div class="orderedlist"><ol type="1" compact><li><p>Initializing a <span class="emphasis"><em>message identifier</em></span>, an integer that helps to disambiguate the sender of the message and/or its purpose.</p></li><li><p>Mapping a specific message type and identifier to an instance method for the message target object.</p></li><li><p>Implementing the actual handler method in the message target.</p></li><li><p>Registering the message target and message identifier with the widget that's going to send the messages.</p></li></ol></div><p>So, for example, let's say you wanted to create a button widget that, when pressed, prints the string "Ouch!" to the terminal. In the old scheme of things, you'd need to identify some object to act as the target for any messages generated by this button. To keep things simple, let's say that the application's main window (<span class="emphasis"><em>mainWindow</em></span>) is designated as the target for the button. We'll need to generate a unique identifier associated with the button:</p><pre class="programlisting">class MyMainWindow &lt; FXMainWindow 

  include Responder

  ID_BUTTON = FXMainWindow::ID_LAST

  ... other stuff ...
end</pre><p>Next, you'd want to specify the mapping for a specific message type to the target's instance method that handles that message:</p><pre class="programlisting">FXMAPFUNC(SEL_COMMAND, MyMainWindow::ID_BUTTON, 'onCmdButton')</pre><p>Finally, you'd need to implement the instance method (<code class="methodname">onCmdButton</code>) named in the call to <code class="methodname">FXMAPFUNC</code>:</p><pre class="programlisting">def onCmdButton(sender, sel, ptr)
  puts "Ouch!"
end</pre><p>The last step is to tell the button who it's message target is, and which message identifier to use when sending messages to that target:</p><pre class="programlisting">aButton = FXButton.new(parent, "Push Me", nil, mainWindow, ID_BUTTON)</pre><p>This was an extremely tedious process, especially for programmers who are used to Ruby/Tk's or Ruby/GTK's approach for connecting signals (events) to blocks that handle the signal. After some discussions at RubyConf 2001 and subsequent discussions on the Ruby newsgroup, a new model was proposed and hashed out on the RubyGarden Wiki. This new model was introduced with the FXRuby-0.99.179 release.</p></div><div class="simplesect" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e2123"></a>Event Model</h2></div></div></div><p>FXRuby implements a new, simplified approach to this built on top of the old model. It more or less mimics the syntax used in Ruby/GTK; you can attach a message handler block to a widget using a new <code class="methodname">connect</code> instance method, e.g.</p><pre class="programlisting">aButton = FXButton.new(parent, "Push Me")
aButton.connect(SEL_COMMAND) { |sender, sel, ptr|
  puts "Ouch!"
}</pre><p>Alternate forms of the <code class="methodname">FXObject#connect</code> method can take either a <code class="classname">Method</code> or <code class="classname">Proc</code> instance as a second argument (i.e. instead of attaching a block), e.g.</p><pre class="programlisting">def push(sender, sel, ptr)
  puts "Ouch!"
end

aButton = FXButton.new(parent, "Push Me")
aButton.connect(SEL_COMMAND, method(:push))</pre><p>It works by creating a special target object (behind the scenes) that stands-in as the message target for your widget and passes off incoming messages to the appropriate block. The single argument to <code class="methodname">connect</code> is the FOX message type you're handling (e.g. <code class="constant">SEL_COMMAND</code>, <code class="constant">SEL_CHANGED</code>, etc.) The three arguments to the block are the same as those for regular FOX message handler methods, namely, the sender object, the message type and identifier and the message data. And of course, for simple handlers like this one, you can just leave the arguments off altogether:</p><pre class="programlisting">aButton = FXButton.new(parent, "Push Me")
aButton.connect(SEL_COMMAND) { puts "Ouch!" }</pre></div><div class="simplesect" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e2159"></a>Timers</h2></div></div></div><p>Timers are scheduled by calling <code class="methodname">FXApp#addTimeout</code>. There are three different forms of <code class="methodname">addTimeout</code>, but the first argument to each is the timeout interval in milliseconds. The most primitive version of this method takes two additional arguments to specify the target object and message identifier for the object that will handle the timeout event:</p><pre class="programlisting">aTimer = getApp().addTimeout(1000, timeoutHandlerObj, ID_TIMER)</pre><p>The second form takes either a <code class="classname">Method</code> or <code class="classname">Proc</code> instance as its second argument, e.g.</p><pre class="programlisting">aTimer = getApp().addTimeout(1000, method(:timeoutHandlerMethod))</pre><p>The last form uses a code block as the handler for the timeout event:</p><pre class="programlisting">aTimer = getApp().addTimeout(1000) { |sender, sel, ptr|
  # handle this timeout event
}</pre></div><div class="simplesect" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e2186"></a>Chores</h2></div></div></div><p>Chores are scheduled by calling <code class="methodname">FXApp#addChore</code>. There are three different forms of <code class="methodname">addChore</code>; the most primitive version requires two arguments to specify the target object and message identifier for the object that will handle the chore event:</p><pre class="programlisting">aChore = getApp().addChore(choreHandlerObj, ID_CHORE)</pre><p>The second form takes either a <code class="classname">Method</code> or <code class="classname">Proc</code> instance as its single argument, e.g.</p><pre class="programlisting">aChore = getApp().addChore(method(:choreHandlerMethod))</pre><p>The last form uses a code block as the handler for the chore:</p><pre class="programlisting">aChore = getApp().addChore { |sender, sel, ptr|
  # handle this chore
}</pre></div><div class="simplesect" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e2213"></a>Signals</h2></div></div></div><p>Operating system signal handlers are designated by calling <code class="methodname">FXApp#addSignal</code>. There are three different forms of <code class="methodname">addSignal</code>, but the first argument to each is the signal name (e.g. "SIGINT") or number. Each version also has two optional arguments (which should come at the end of the list) to specify <em class="parameter"><code>immediate</code></em> and <em class="parameter"><code>flags</code></em>. The most primitive version of this method takes two additional arguments to specify the target object and message identifier for the object that will handle this operating system signal:</p><pre class="programlisting">aSignal = getApp().addSignal("SIGINT", signalHandlerObj, ID_SIGINT)</pre><p>The second form takes either a <code class="classname">Method</code> or <code class="classname">Proc</code> instance as its second argument, e.g.</p><pre class="programlisting">aSignal = getApp().addSignal("SIGINT", method(:signalHandlerMethod))</pre><p>The last form uses a code block as the handler for the signal:</p><pre class="programlisting">aSignal = getApp().addSignal("SIGINT") { |sender, sel, ptr|
  # handle this signal
}</pre></div><div class="simplesect" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e2246"></a>Input Events</h2></div></div></div><p>Input event handlers are designated by calling <code class="methodname">FXApp#addInput</code>. There are three different forms of <code class="methodname">addInput</code>, but the first two arguments to each are the file object (including sockets) and the mode flag (some combination of <code class="constant">INPUT_READ</code>, <code class="constant">INPUT_WRITE</code> and <code class="constant">INPUT_EXCEPT</code>). The most primitive version of this method takes two additional arguments to specify the target object and message identifier for the object that will handle this input event:</p><pre class="programlisting">getApp().addInput(aFile, INPUT_READ, inputHandlerObj, ID_INPUT)</pre><p>The second form takes either a <code class="classname">Method</code> or <code class="classname">Proc</code> instance as its third argument, e.g.</p><pre class="programlisting">getApp().addInput(aSocket, INPUT_READ|INPUT_EXCEPT, method(:inputHandlerMethod))</pre><p>The last form uses a code block as the handler for the input event:</p><pre class="programlisting">getApp().addInput(aFile, INPUT_WRITE|INPUT_EXCEPT) { |sender, sel, ptr|
  # handle this input
}</pre><p>This API is a little different from the other cases. For example, timeout events always send the same message type (<code class="constant">SEL_TIMEOUT</code>) to their message target, so you just have a single handler method (or block) to handle the timeout. In contrast, input sources (e.g. pipes or sockets) can generate three different FOX messages, <code class="constant">SEL_IO_READ</code>, <code class="constant">SEL_IO_WRITE</code> and <code class="constant">SEL_IO_EXCEPTION</code>, depending on what happens, so your handler method (block) needs to check the message type, e.g.</p><pre class="programlisting">getApp().addInput(socket, INPUT_READ|INPUT_WRITE) { |sender, sel, ptr|
  case SELTYPE(sel)
    when SEL_IO_READ
      # handle read event
    when SEL_IO_WRITE
      # handle write event
  end    
}</pre></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="examples.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="pt01.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="todo.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter&nbsp;7.&nbsp;Examples&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="book.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;Chapter&nbsp;9.&nbsp;To-do list</td></tr></table></div></body></html>