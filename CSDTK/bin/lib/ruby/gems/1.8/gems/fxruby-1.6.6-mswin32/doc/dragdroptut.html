<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Chapter&nbsp;5.&nbsp;Drag and Drop</title><link rel="stylesheet" href="style.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.68.1"><link rel="start" href="book.html" title="Developing Graphical User Interfaces with FXRuby"><link rel="up" href="pt01.html" title="Part&nbsp;I.&nbsp;The Basics"><link rel="prev" href="ch04s04.html" title="Pasting Data from the Clipboard"><link rel="next" href="ch05s02.html" title="Drag Sources"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter&nbsp;5.&nbsp;Drag and Drop</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch04s04.html">Prev</a>&nbsp;</td><th width="60%" align="center">Part&nbsp;I.&nbsp;The Basics</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="ch05s02.html">Next</a></td></tr></table><hr></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="dragdroptut"></a>Chapter&nbsp;5.&nbsp;Drag and Drop</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="dragdroptut.html#d0e1201">Drop Sites</a></span></dt><dt><span class="section"><a href="ch05s02.html">Drag Sources</a></span></dt><dt><span class="section"><a href="ch05s03.html">Putting It All Together</a></span></dt></dl></div><p>One of the more powerful features available to FOX applications is
  drag-and-drop. It's also one of the more complicated to understand. For more
  background, see the standard FOX documentation on <a href="http://www.fox-toolkit.com/draganddrop.html" target="_top">Drag and
  Drop</a>.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e1201"></a>Drop Sites</h2></div></div></div><p>We're going to start by presenting a skeleton application consisting
    of a main window widget (a <code class="classname">DropSite</code> instance) that
    parents an <code class="classname">FXCanvas</code> widget:</p><pre class="programlisting">require 'rubygems'
require_gem 'fxruby'

include Fox

class DropSite &lt; FXMainWindow
  def initialize(anApp)
    # Initialize base class
    super(anApp, "Drop Site", nil, nil, DECOR_ALL, 0, 0, 400, 300)
    
    # Fill main window with canvas
    @canvas = FXCanvas.new(self, nil, 0, LAYOUT_FILL_X|LAYOUT_FILL_Y)
  end

  def create
    # Create the main window and canvas
    super

    # Show the main window
    show(PLACEMENT_SCREEN)
  end
end

if __FILE__ == $0
  FXApp.new("DropSite", "FXRuby") do |theApp|
    DropSite.new(theApp)
    theApp.create
    theApp.run
  end
end
</pre><p>Since the main program (i.e. the part at the end) won't change for
    the rest of the tutorial, I won't show that code anymore. Since an
    <code class="classname">FXCanvas</code> widget relies on some other object (its
    message target) to draw its contents, we need to handle
    <code class="constant">SEL_PAINT</code> messages generated by the canvas. We'll do
    that by adding a handler that clears the canvas to its current background
    color:</p><pre class="programlisting">require 'rubygems'
require_gem 'fxruby'

include Fox

class DropSite &lt; FXMainWindow
  def initialize(anApp)
    # Initialize base class
    super(anApp, "Drop Site", nil, nil, DECOR_ALL, 0, 0, 400, 300)
    
    # Fill main window with canvas
    @canvas = FXCanvas.new(self, nil, 0, LAYOUT_FILL_X|LAYOUT_FILL_Y)
    
<span class="bold"><strong>    # Handle expose events on the canvas
    @canvas.connect(SEL_PAINT) { |sender, sel, event|
      FXDCWindow.new(@canvas, event) { |dc|
        dc.foreground = @canvas.backColor
        dc.fillRectangle(event.rect.x, event.rect.y, event.rect.w, event.rect.h)
      }
    }</strong></span>
  end

  def create
    # Create the main window and canvas
    super

    # Show the main window
    show(PLACEMENT_SCREEN)
  end
end
</pre><p>Run this basic version of the program to be sure that it's working
    properly so far. You should simply see an empty window with a white
    background.</p><p>Now, on to the fun stuff. Our goal is to be able to drag color data
    from some other window, such as an <code class="classname">FXColorWell</code>
    widget, and drop it onto the canvas in order to change the canvas'
    background color. In order for a FOX widget to be able to accept drops at
    all, we need to first call its <code class="methodname">dropEnable()</code>
    method:</p><pre class="programlisting">def initialize(anApp)
  # Initialize base class
  super(anApp, "Drop Site", nil, nil, DECOR_ALL, 0, 0, 400, 300)
  
  # Fill main window with canvas
  @canvas = FXCanvas.new(self, nil, 0, LAYOUT_FILL_X|LAYOUT_FILL_Y)
    
  # Handle expose events on the canvas
  @canvas.connect(SEL_PAINT) { |sender, sel, event|
    FXDCWindow.new(@canvas, event) { |dc|
      dc.foreground = @canvas.backColor
      dc.fillRectangle(event.rect.x, event.rect.y, event.rect.w, event.rect.h)
    }
  }

<span class="bold"><strong>  # Enable canvas for drag-and-drop messages
  @canvas.dropEnable
</strong></span>end
</pre><p>At this point, let's try a little test to see if the program does
    anything interesting yet. Start by running some other FOX or FXRuby
    program to use as a drag source for the color data. You should be able to
    use any program that displays an FXColorWell widget, and this includes the
    standard color dialog box shown here:</p><div class="screenshot"><div class="mediaobject" align="center"><img src="images/colordialog.png" align="middle"></div></div><p>Each of the small colored boxes near the bottom of the color dialog
    box are color wells, and the large box on the left-hand side of the color
    dialog box is also a color well. Now start your drag-and-drop test program
    and try to drag a color from one of these color wells onto this window. At
    this point, the mouse pointer should turn into a stop sign, indicating
    that the canvas isn't accepting drops of color data yet.</p><p>To correct this problem, we need to use the canvas'
    <code class="methodname">acceptDrop()</code> method to indicate whether or not
    we'll accept certain kinds of drops. You can call
    <code class="methodname">acceptDrop()</code> any time after receiving the initial
    <code class="constant">SEL_DND_ENTER</code> message, but it's usually done in
    response to a <code class="constant">SEL_DND_MOTION</code> message. Let's add a
    handler for <code class="constant">SEL_DND_MOTION</code> messages from the canvas
    in DropSite's initialize() method. For now, we'll unconditionally accept
    drops from any drag source, regardless of what kind of data they're
    offering:</p><pre class="programlisting">def initialize(anApp)
  # Initialize base class
  super(anApp, "Drop Site", nil, nil, DECOR_ALL, 0, 0, 400, 300)
    
  # Fill main window with canvas
  @canvas = FXCanvas.new(self, nil, 0, LAYOUT_FILL_X|LAYOUT_FILL_Y)
    
  # Handle expose events on the canvas
  @canvas.connect(SEL_PAINT) { |sender, sel, event|
    FXDCWindow.new(@canvas, event) { |dc|
      dc.foreground = @canvas.backColor
      dc.fillRectangle(event.rect.x, event.rect.y, event.rect.w, event.rect.h)
    }
  }

  # Enable canvas for drag-and-drop messages
  @canvas.dropEnable
  
<span class="bold"><strong>  # Handle SEL_DND_MOTION messages from the canvas
  @canvas.connect(SEL_DND_MOTION) {
    # Accept drops unconditionally (for now)
    @canvas.acceptDrop
  }
</strong></span>end
</pre><p>Now try the previous test again. This time, when you try to drag
    from a color well to the drop-enabled canvas, you should see the mouse
    pointer turn into a small filled square. This is a visual cue to the user
    indicating that the canvas will accept a drop of the drag-and-drop
    data.</p><p>Now it's time to get more specific about what kind of data is being
    dragged between these applications, and how to process that data. So far,
    our drop-enabled canvas merely knows that you're dragging some kind of
    data from a drag source, but it doesn't know what kind of data it is. We
    really need to be more exclusive about what kinds of data are acceptable.
    FOX uses unique drag types to distinguish between different kinds of
    "draggable" data. As you'll see later, you have the freedom to define drag
    types for any kind of application-specific data that you need; but for
    now, we're going to use FOX's built-in drag type for color data.</p><p>Drag types (even the standard ones) must be registered before they
    can be used, and so we'll start by adding a few lines to
    <code class="classname">DropSite</code>'s <code class="methodname">create()</code> method
    to register the drag type for color data:</p><pre class="programlisting">def create
  # Create the main window and canvas
  super
  
<span class="bold"><strong>  # Register the drag type for colors
  FXWindow.colorType = getApp().registerDragType(FXWindow.colorTypeName)

</strong></span>  # Show the main window
  show(PLACEMENT_SCREEN)
end
</pre><p>Note that the first time that
    <code class="methodname">registerDragType()</code> is called for a particular
    drag type name (such as <code class="methodname">FXWindow.colorTypeName</code>)
    it will generate a unique identifier for that drag type. Subsequent calls
    to <code class="methodname">registerDragType()</code> for the same drag type name
    will just return the previously-generated drag type. Now, we want to
    modify our <code class="constant">SEL_DND_MOTION</code> handler so that it's a
    little more picky about which kinds of drops it will accept:</p><pre class="programlisting"># Handle SEL_DND_MOTION messages from the canvas
@canvas.connect(SEL_DND_MOTION) {
<span class="bold"><strong>  if @canvas.offeredDNDType?(FROM_DRAGNDROP, FXWindow.colorType)
    @canvas.acceptDrop
  end
</strong></span>}
</pre><p>Here, we call the canvas' <code class="methodname">offeredDNDType?</code>
    method to ask if the drag source can provide its data in the requested
    format. Only if <code class="methodname">offeredDNDType?</code> returns true will
    we call <code class="methodname">acceptDrop()</code> as before.</p><p>The last step is to actually handle the drop, and for that we add a
    handler for the <code class="constant">SEL_DND_DROP</code> message:</p><pre class="programlisting"><span class="bold"><strong># Handle SEL_DND_DROP message from the canvas
@canvas.connect(SEL_DND_DROP) {
  # Try to obtain the data as color values first
  data = @canvas.getDNDData(FROM_DRAGNDROP, FXWindow.colorType)
  unless data.nil?
    # Update canvas background color
    @canvas.backColor = Fox.fxdecodeColorData(data)
  end
}</strong></span></pre><p>Assuming that the drag source is able to provide its data in the
    requested format, the <code class="methodname">getDNDData()</code> method will
    return a String (which for our purposes is just a byte buffer). If you've
    defined your own application-specific drag types, this data can of course
    be anything, and we'll see examples of this in a later tutorial. But the
    data for standard drag types like
    <code class="methodname">FXWindow.colorType</code> can be decoded using the
    appropriate built-in library functions. In this case, we use the
    <code class="methodname">fxdecodeColorData()</code> method to convert the bytes
    into a color value that we can use.</p><p>Now comes the moment of truth. Try running your test program again
    (one that displays a color well). Now, when you drag a color from a color
    well and drop it onto the <code class="classname">DropSite</code> window, the
    canvas should change its background color accordingly.</p><p>The complete program is listed below, and is included in the
    <code class="filename">examples</code> directory under the file
    name <code class="filename">dropsite.rb</code>.</p><pre class="programlisting">require 'rubygems'
require_gem 'fxruby'

include Fox

class DropSite &lt; FXMainWindow
  def initialize(anApp)
    # Initialize base class
    super(anApp, "Drop Site", nil, nil, DECOR_ALL, 0, 0, 400, 300)
    
    # Fill main window with canvas
    @canvas = FXCanvas.new(self, nil, 0, LAYOUT_FILL_X|LAYOUT_FILL_Y)
    
    # Handle expose events on the canvas
    @canvas.connect(SEL_PAINT) { |sender, sel, event|
      FXDCWindow.new(@canvas, event) { |dc|
        dc.foreground = @canvas.backColor
        dc.fillRectangle(event.rect.x, event.rect.y, event.rect.w, event.rect.h)
      }
    }

    # Enable canvas for drag-and-drop messages
    @canvas.dropEnable
    
    # Handle SEL_DND_MOTION messages from the canvas
    @canvas.connect(SEL_DND_MOTION) {
      if @canvas.offeredDNDType?(FROM_DRAGNDROP, FXWindow.colorType)
        @canvas.acceptDrop
      end
    }

    # Handle SEL_DND_DROP message from the canvas
    @canvas.connect(SEL_DND_DROP) {
      # Try to obtain the data as color values first
      data = @canvas.getDNDData(FROM_DRAGNDROP, FXWindow.colorType)
      unless data.nil?
        # Update canvas background color
        @canvas.backColor = Fox.fxdecodeColorData(data)
      end
    }
  end

  def create
    # Create the main window and canvas
    super
    
    # Register the drag type for colors
    FXWindow.colorType = getApp().registerDragType(FXWindow.colorTypeName)

    # Show the main window
    show(PLACEMENT_SCREEN)
  end
end

if __FILE__ == $0
  FXApp.new("DropSite", "FXRuby") do |theApp|
    DropSite.new(theApp)
    theApp.create
    theApp.run
  end
end
</pre></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch04s04.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="pt01.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="ch05s02.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Pasting Data from the Clipboard&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="book.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;Drag Sources</td></tr></table></div></body></html>